(function(){"use strict";const i={START_DOWNLOAD:"START_DOWNLOAD",DOWNLOAD_PROGRESS:"DOWNLOAD_PROGRESS",DOWNLOAD_COMPLETE:"DOWNLOAD_COMPLETE",GET_DOWNLOAD_STATUS:"GET_DOWNLOAD_STATUS"},h={DOWNLOADING:"downloading",COMPLETE:"complete"},f={EXTRACTION:1e4,DOWNLOAD_DELAY:500,NOTIFICATION_DURATION:3e3,BUTTON_RESET:3e3};class D{currentLevel;prefix="[Libby Downloader]";constructor(){this.currentLevel=1}setLevel(e){this.currentLevel=e}debug(e,t){this.currentLevel<=0&&(t?console.log(`${this.prefix} [DEBUG]`,e,t):console.log(`${this.prefix} [DEBUG]`,e))}info(e,t){this.currentLevel<=1&&(t?console.log(`${this.prefix}`,e,t):console.log(`${this.prefix}`,e))}warn(e,t){this.currentLevel<=2&&(t?console.warn(`${this.prefix} [WARN]`,e,t):console.warn(`${this.prefix} [WARN]`,e))}error(e,t,o){this.currentLevel<=3&&(t instanceof Error?console.error(`${this.prefix} [ERROR]`,e,{error:t.message,stack:void 0,...o}):t!==void 0?console.error(`${this.prefix} [ERROR]`,e,{error:t,...o}):o?console.error(`${this.prefix} [ERROR]`,e,o):console.error(`${this.prefix} [ERROR]`,e))}operationStart(e,t){this.debug(`Starting: ${e}`,t)}operationComplete(e,t){this.debug(`Completed: ${e}`,t)}operationFailed(e,t,o){this.error(`Failed: ${e}`,t,o)}}const l=new D;class w extends Error{constructor(e){super(e),this.name="LibbyDownloaderError",Object.setPrototypeOf(this,w.prototype)}}class p extends w{constructor(e,t,o){super(e),this.chapterIndex=t,this.cause=o,this.name="DownloadError",Object.setPrototypeOf(this,p.prototype)}}function u(s){return s.replace(/[/\\?%*:|"<>]/g,"-").substring(0,200)}class O{async downloadChapter(e,t,o){const r=String(o+1).padStart(3,"0"),a=`libby-downloads/${u(t)}/chapter-${r}.mp3`;l.operationStart(`Download chapter ${o+1}`,{title:e.title,filename:a});const n=await chrome.downloads.download({url:e.url,filename:a,saveAs:!1}),d=await this.waitForDownload(n);return{downloadId:n,filepath:d,chapterIndex:o}}async downloadAllChapters(e,t,o){const r={completed:0,failed:0,total:e.length,downloadIds:[],errors:[]};for(let a=0;a<e.length;a++)try{const n=await this.downloadChapter(e[a],t,a);r.downloadIds.push(n.downloadId),r.completed++,l.operationComplete(`Download chapter ${a+1}/${e.length}`),o&&o(r.completed,r.total),await this.sleep(f.DOWNLOAD_DELAY)}catch(n){const d=new p(`Failed to download chapter ${a+1}`,a,n instanceof Error?n:void 0);l.operationFailed(`Download chapter ${a+1}`,d),r.failed++,r.errors.push({chapterIndex:a,error:n instanceof Error?n.message:"Unknown error"})}return r}waitForDownload(e){return new Promise((t,o)=>{const r=setInterval(async()=>{const a=await chrome.downloads.search({id:e});if(a.length===0){clearInterval(r),o(new Error("Download not found"));return}const n=a[0];n.state==="complete"&&(clearInterval(r),n.filename?t(n.filename):o(new Error("Download completed but filename is undefined"))),(n.state==="interrupted"||n.error)&&(clearInterval(r),o(new Error(n.error||"Download interrupted")))},500)})}sleep(e){return new Promise(t=>setTimeout(t,e))}}class m{activeDownloads=new Map;createDownload(e){const t=`${Date.now()}`,{metadata:o,chapters:r}=e,a={bookId:t,metadata:o,totalChapters:r.length,completedChapters:0,failedChapters:0,downloadIds:[],startTime:Date.now(),status:h.DOWNLOADING};return this.activeDownloads.set(t,a),t}updateProgress(e,t,o=0){const r=this.activeDownloads.get(e);r&&(r.completedChapters=t,r.failedChapters=o)}completeDownload(e,t){const o=this.activeDownloads.get(e);o&&(o.status=h.COMPLETE,o.endTime=Date.now(),o.completedChapters=t.completed,o.failedChapters=t.failed)}getDownloadStatus(e){return this.activeDownloads.get(e)||null}removeDownload(e){this.activeDownloads.delete(e)}}class E{async saveMetadata(e,t,o){const r=JSON.stringify({metadata:e,chapters:t},null,2),a="data:application/json;charset=utf-8,"+encodeURIComponent(r);return await chrome.downloads.download({url:a,filename:`libby-downloads/${u(o)}/metadata.json`,saveAs:!1})}}l.info("Background service worker loaded");const L=new O,c=new m,T=new E;async function v(s,e){const{metadata:t,chapters:o}=s;l.info("Starting download",{title:t.title,chapters:o.length});const r=c.createDownload(s),a=await L.downloadAllChapters(o,t.title,(n,d)=>{c.updateProgress(r,n),chrome.tabs.sendMessage(e,{type:i.DOWNLOAD_PROGRESS,progress:{completed:n,total:d}}).catch(()=>{})});c.completeDownload(r,a);try{await T.saveMetadata(t,o,t.title)}catch(n){console.error("[Libby Downloader] Failed to save metadata file:",n)}return chrome.tabs.sendMessage(e,{type:i.DOWNLOAD_COMPLETE,result:{completed:a.completed,failed:a.failed,total:a.total}}).catch(()=>{}),{bookId:r,completed:a.completed,failed:a.failed,total:a.total}}chrome.runtime.onMessage.addListener((s,e,t)=>{if(l.debug("Received message",{type:s.type}),s.type===i.START_DOWNLOAD){const o=e.tab?.id;return o?(v(s.data,o).then(r=>t({success:!0,result:r})).catch(r=>t({success:!1,error:r instanceof Error?r.message:"Unknown error"})),!0):(t({success:!1,error:"No tab ID available"}),!0)}if(s.type===i.GET_DOWNLOAD_STATUS){const o=c.getDownloadStatus(s.bookId);return t({status:o}),!0}return!1}),chrome.downloads.onChanged.addListener(s=>{s.error&&console.error(`[Libby Downloader] Download ${s.id} error:`,s.error.current)}),l.info("Background service worker ready")})();
