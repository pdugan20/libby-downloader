import{T as w,D as i,M as s}from"../assets/messages-CwU8PCpU.js";function u(n){return n.replace(/[/\\?%*:|"<>]/g,"-").substring(0,200)}class p{async downloadChapter(a,t,e){const o=String(e+1).padStart(3,"0"),r=`libby-downloads/${u(t)}/chapter-${o}.mp3`;console.log(`[Download Service] Downloading chapter ${e+1}: ${a.title}`);const l=await chrome.downloads.download({url:a.url,filename:r,saveAs:!1}),c=await this.waitForDownload(l);return{downloadId:l,filepath:c,chapterIndex:e}}async downloadAllChapters(a,t,e){const o={completed:0,failed:0,total:a.length,downloadIds:[],errors:[]};for(let r=0;r<a.length;r++)try{const l=await this.downloadChapter(a[r],t,r);o.downloadIds.push(l.downloadId),o.completed++,console.log(`[Download Service] Chapter ${r+1}/${a.length} complete`),e&&e(o.completed,o.total),await this.sleep(w.DOWNLOAD_DELAY)}catch(l){console.error(`[Download Service] Failed to download chapter ${r+1}:`,l),o.failed++,o.errors.push({chapterIndex:r,error:l instanceof Error?l.message:"Unknown error"})}return o}waitForDownload(a){return new Promise((t,e)=>{const o=setInterval(async()=>{const r=await chrome.downloads.search({id:a});if(r.length===0){clearInterval(o),e(new Error("Download not found"));return}const l=r[0];l.state==="complete"&&(clearInterval(o),l.filename?t(l.filename):e(new Error("Download completed but filename is undefined"))),(l.state==="interrupted"||l.error)&&(clearInterval(o),e(new Error(l.error||"Download interrupted")))},500)})}sleep(a){return new Promise(t=>setTimeout(t,a))}}class h{activeDownloads=new Map;createDownload(a){const t=`${Date.now()}`,{metadata:e,chapters:o}=a,r={bookId:t,metadata:e,totalChapters:o.length,completedChapters:0,failedChapters:0,downloadIds:[],startTime:Date.now(),status:i.DOWNLOADING};return this.activeDownloads.set(t,r),console.log(`[Download Tracker] Created download: ${e.title} (ID: ${t})`),t}updateProgress(a,t,e=0){const o=this.activeDownloads.get(a);o&&(o.completedChapters=t,o.failedChapters=e)}completeDownload(a,t){const e=this.activeDownloads.get(a);if(!e)return;e.status=i.COMPLETE,e.endTime=Date.now(),e.completedChapters=t.completed,e.failedChapters=t.failed;const o=Math.round((e.endTime-e.startTime)/1e3);console.log(`[Download Tracker] Download complete: ${e.completedChapters}/${e.totalChapters} chapters in ${o}s`)}getDownloadStatus(a){return this.activeDownloads.get(a)||null}removeDownload(a){this.activeDownloads.delete(a)}}function D(n){return n.replace(/[/\\?%*:|"<>]/g,"-").substring(0,200)}class m{async saveMetadata(a,t,e){console.log("[Metadata Writer] Saving metadata file");const o=JSON.stringify({metadata:a,chapters:t},null,2),r="data:application/json;charset=utf-8,"+encodeURIComponent(o),l=await chrome.downloads.download({url:r,filename:`libby-downloads/${D(e)}/metadata.json`,saveAs:!1});return console.log("[Metadata Writer] Metadata file download started"),l}}console.log("[Libby Downloader] Background service worker loaded");const f=new p,d=new h,g=new m;async function b(n,a){const{metadata:t,chapters:e}=n;console.log(`[Libby Downloader] Starting download: ${t.title} (${e.length} chapters)`);const o=d.createDownload(n),r=await f.downloadAllChapters(e,t.title,(l,c)=>{d.updateProgress(o,l),chrome.tabs.sendMessage(a,{type:s.DOWNLOAD_PROGRESS,progress:{completed:l,total:c}}).catch(()=>{})});d.completeDownload(o,r);try{await g.saveMetadata(t,e,t.title)}catch(l){console.error("[Libby Downloader] Failed to save metadata file:",l)}return chrome.tabs.sendMessage(a,{type:s.DOWNLOAD_COMPLETE,result:{completed:r.completed,failed:r.failed,total:r.total}}).catch(()=>{}),{bookId:o,completed:r.completed,failed:r.failed,total:r.total}}chrome.runtime.onMessage.addListener((n,a,t)=>{if(console.log("[Libby Downloader] Received message:",n.type),n.type===s.START_DOWNLOAD){const e=a.tab?.id;return e?(b(n.data,e).then(o=>t({success:!0,result:o})).catch(o=>t({success:!1,error:o instanceof Error?o.message:"Unknown error"})),!0):(t({success:!1,error:"No tab ID available"}),!0)}if(n.type===s.GET_DOWNLOAD_STATUS){const e=d.getDownloadStatus(n.bookId);return t({status:e}),!0}return!1});chrome.downloads.onChanged.addListener(n=>{n.state&&n.state.current==="complete"&&console.log(`[Libby Downloader] Download ${n.id} completed`),n.error&&console.error(`[Libby Downloader] Download ${n.id} error:`,n.error.current)});console.log("[Libby Downloader] Background service worker ready");
